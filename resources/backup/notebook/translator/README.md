# Translator of Case Notebooks

Translates case notebook narratives (extension of markdown) to object representations and further to HTML. 

Regular expressions checked through [RegExr](https://regexr.com/).
Regular expression images generated by [Regulex](https://jex.im/regulex/).

# Knot
### Markdown to Object
* Sentence: `== [title] ([category]) ==`
* Expression: `^[ \t]*==*[ \t]*(\w[\w \t]*)(?:\(([\w \t]*)\))?[ \t]*=*[ \t]*[\f\n\r]`
  * Group #1: title
  * Group #2: category
![Knot Expression](expressions/knot.png)
* Object:
```
{
   type: "knot"
   title: <title of the knot>
   category: <knot category>
   content: [<elements subordinated to this knot>]
   annotations: [<set of annotations]
}
```

# Annotations

## Context
* Sentence context open: `{{ [context] #[evaluation]: [option-1], ..., [option-n]; [color-1], ... [color-n]`
* Expression context open: `\{\{([\w \t\+\-\*"=\:%\/]+)(?:#([\w \t\+\-\*"=\%\/]+):([\w \t\+\-\*"=\%\/,]+);([\w \t#,]+)?)?[\f\n\r]`
  * Group #1: context
  * Group #2: evaluation
  * Group #3: list of options
  * Group #4: list of colors
![Context Open](expressions/context-open.png)
* Sentence context close: `}}`
* Expression context close: `\}\}` 
![Context Close](expressions/context-close.png)
* Object:
```
{
   type: "context"
   context: <identification of the context>
   evaluation: <characteristic being evaluated in the context - for selector>
   options: <set of options>
   annotations: [<set of annotations in this context>]
}
```

## Annotation
* Sentence outside: `{ [natural] ([formal]) #[context value] }`
* Expression outside: `\{([\w \t\+\-\*"=\:%\/]+)(?:\(([\w \t\+\-\*"=\:%\/]+)\)[ \t]*)?(?:#([\w \t\+\-\*"=\:%\/]+))?\}`
  * Group #1: natural
  * Group #2: formal
  * Group #3: context value (intended for evaluations based on selectors)
![Domain Outside](expressions/domain-outside.png)
* Sentence inside: `[expression] =|: [specification] / [rate]`
* Expression inside: `([\w \t\+\-\*"]+)(?:[=\:]([\w \t%]*)(?:\/([\w \t%]*))?)?`
  * Group #1: expression
  * Group #2: specification
  * Group #3: rate
![Domain Inside](expressions/domain-inside.png)
* Object:
```
{
   type: "domain"
   natural: {
      complete: <complete text in natural language>
      expression: <expression in the text to be evaluated>
      specification: <specify the expression defining, for example, a measurable value, rate or origin>
      rate: <compose the rate of the specification>
   }
   formal: {
      complete: <complete text written in formal way to be recognized against a dictionary>
      expression: <expression in the text to be evaluated>
      specification: <specify the expression defining, for example, a measurable value, rate or origin>
      rate: <compose the rate of the specification>
   }
   value: <value of the expression according to the context> 
}
```

# Items

## Text
Markdown text that does not match to any expression.
* Object:
```
{
   type: "text"
   id: 
   content: <unprocessed content in markdown>
}
```

## Option
### Markdown to Object
* Sentence: `++ [label] -> [target]`
* Expression: `[ \t]*\+\+[ \t]*([^-&<> \t][^-&<>\n\r\f]*)?(?:-(?:(?:&gt;)|>)[ \t]*(\w[\w. \t]*))?[\f\n\r]`
  * Group #1: label
  * Group #2: target
![Option Expression](expressions/option.png)
* Object:
```
{
   type: "option"
   label: <label to be displayed -- if there is not an explicit target, the label is the target>
   target: <target node to divert>
}
```
### Object to HTML
```
<dcc-trigger link='[link].html' label='[display]' [image]></dcc-trigger>
   [image] -> image='[image-file].svg' location='control-panel'
```

## Divert
### Markdown to Object
* Sentence: `-> [target]`
* Expression: `-(?:(?:&gt;)|>) *(\w[\w. ]*)`
  * Group #1: target
![Divert Expression](expressions/divert.png)
* Object:
```
{
   type: "divert"
   target: <target node to divert>
}
```
### Object to HTML
```
<dcc-trigger link='[link].html' label='[display]'></dcc-trigger>
```

## Talk
### Markdown to Object
* Sentence: `:[character]: [talk]`
* Expression: `^[ \t]*: *(\w[\w ]*):[ \t]*([^\n\r\f]+)`
  * Group #1: character
  * Group #2: speech
![talk Expression](expressions/talk.png)
* Object:
```
{
   type: "talk"
   character: <identification of the character>
   speech: <character's speech>
}
```
### Object to HTML
```
<dcc-lively-talk character='[character]' speech='[speech]'>
</dcc-lively-talk>
```

## Input
### Markdown to Object
* Sentence: `{?[rows]  [variable]: [vocabulary]}`
* Expression: `\{[ \t]*\?(\d+)?([\w \t]*)(?:\:([\w \t]*))?\}`
  * Group #1: rows
  * Group #2: variable
  * Group #3: vocabulary
![Input Expression](expressions/input.png)
* Object:
```
{
   type: "input"
   variable: <variable that will receive the input>
   rows: <number of rows for the input>
   vocabulary: <the vocabulary to interpret the input>
}
```
### Object to HTML
```
<[input-type] [input-parameters] class='userInput' id='[variable]'
   oninput="followInput('[variable]','[vocabulary]')">
</[input-type]>
<span id='[variable]_result'></span>
```

## Selector Context
### -- Open
### Markdown to Object
* Sentence context open: `{{ [context] #[evaluation]: [option-1], ..., [option-n]; [color-1], ... [color-n]`
* Expression context open: `\{\{([\w \t\+\-\*"=\:%\/]+)(?:#([\w \t\+\-\*"=\%\/]+):([\w \t\+\-\*"=\%\/,]+);([\w \t#,]+)?)?[\f\n\r]`
  * Group #1: context
  * Group #2: evaluation
  * Group #3: list of options
  * Group #4: list of colors
![Context Open](expressions/context-open.png)
* Object:
```
{
   type: "context-open"
   context: <identification of the context> #1
   evaluation: <characteristic being evaluated in the context> #2
   options: <set of options> #3
   colors: <set of colors> #4
}
```
### Object to HTML
```
<dcc-group-selector states='[options]' colors='[colors]'>
```
### -- Close
### Markdown to Object
* Sentence context close: `}}`
* Expression context close: `\}\}` 
![Context Close](expressions/context-close.png)
* Object:
```
{
   type: "context-close"
}
```
### Object to HTML
```
</dcc-group-selector>
```

## Selector
* Sentence: `{ [natural] ([formal]) #[context value])`
* Expression: <equivalent to an annotation>
  * Group #1: natural
  * Group #2: formal (extracted in an annotation)
  * Group #3: context value
![Selector Expression](expressions/selector.png)
* Object:
```
{
   type: "selector"
   expression: <expression to be evaluated (natural)>
   value: <right value of the expression according to the evaluated context>
}
```
### Object to HTML
```
<dcc-state-selector>[expression]</dcc-state-selector>
```

